import { NextRequest, NextResponse } from "next/server";
import { bundle } from "@remotion/bundler";
import { renderMedia, selectComposition } from "@remotion/renderer";
import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";
import * as http from "http";

export const maxDuration = 300; // 5 minute timeout for rendering

interface VideoComposerRequest {
  code: string; // Remotion TSX code generated by LLM
  videos: string[]; // Array of base64 video data URLs
  images: string[]; // Array of base64 image data URLs
  duration: number; // Duration in seconds
  aspectRatio: "9:16" | "16:9" | "1:1";
  fps: number;
}

interface AssetServer {
  server: http.Server;
  baseUrl: string;
}

// Create a simple HTTP server to serve assets (videos and images)
function createAssetServer(
  tempDir: string,
  videos: string[],
  images: string[]
): Promise<AssetServer> {
  return new Promise((resolve, reject) => {
    const server = http.createServer(async (req, res) => {
      const url = req.url || "/";

      try {
        // Parse the URL to get the asset type and index
        const videoMatch = url.match(/^\/video(\d+)\.(mp4|webm)$/);
        const imageMatch = url.match(/^\/image(\d+)\.(png|jpg|jpeg|webp)$/);

        if (videoMatch) {
          const index = parseInt(videoMatch[1]) - 1; // 1-indexed to 0-indexed
          const assetPath = path.join(tempDir, `video${index + 1}.mp4`);
          const buffer = await fs.readFile(assetPath);
          res.writeHead(200, {
            "Content-Type": "video/mp4",
            "Content-Length": buffer.length,
            "Access-Control-Allow-Origin": "*",
          });
          res.end(buffer);
        } else if (imageMatch) {
          const index = parseInt(imageMatch[1]) - 1;
          const ext = imageMatch[2];
          const assetPath = path.join(tempDir, `image${index + 1}.${ext}`);
          const buffer = await fs.readFile(assetPath);
          const contentType = ext === "png" ? "image/png" :
                             ext === "webp" ? "image/webp" : "image/jpeg";
          res.writeHead(200, {
            "Content-Type": contentType,
            "Content-Length": buffer.length,
            "Access-Control-Allow-Origin": "*",
          });
          res.end(buffer);
        } else {
          res.writeHead(404);
          res.end("Not found");
        }
      } catch (error) {
        console.error("[VideoComposer] Asset server error:", error);
        res.writeHead(500);
        res.end("Error reading asset");
      }
    });

    server.listen(0, "127.0.0.1", () => {
      const address = server.address();
      if (address && typeof address === "object") {
        const baseUrl = `http://127.0.0.1:${address.port}`;
        resolve({ server, baseUrl });
      } else {
        reject(new Error("Failed to get server address"));
      }
    });

    server.on("error", reject);
  });
}

// Save base64 assets to temp directory
async function saveAssets(
  tempDir: string,
  videos: string[],
  images: string[]
): Promise<{ videoUrls: string[]; imageUrls: string[] }> {
  const videoUrls: string[] = [];
  const imageUrls: string[] = [];

  // Save videos
  for (let i = 0; i < videos.length; i++) {
    const video = videos[i];
    const match = video.match(/^data:video\/([^;]+);base64,(.+)$/);
    if (match) {
      const buffer = Buffer.from(match[2], "base64");
      const filePath = path.join(tempDir, `video${i + 1}.mp4`);
      await fs.writeFile(filePath, buffer);
      videoUrls.push(`/video${i + 1}.mp4`);
    }
  }

  // Save images
  for (let i = 0; i < images.length; i++) {
    const image = images[i];
    const match = image.match(/^data:image\/([^;]+);base64,(.+)$/);
    if (match) {
      const ext = match[1] === "jpeg" ? "jpg" : match[1];
      const buffer = Buffer.from(match[2], "base64");
      const filePath = path.join(tempDir, `image${i + 1}.${ext}`);
      await fs.writeFile(filePath, buffer);
      imageUrls.push(`/image${i + 1}.${ext}`);
    }
  }

  return { videoUrls, imageUrls };
}

// Create the dynamic Remotion composition entry point
function createCompositionCode(
  userCode: string,
  assetBaseUrl: string,
  videoUrls: string[],
  imageUrls: string[],
  width: number,
  height: number,
  fps: number,
  durationInFrames: number
): string {
  // Create asset URL mappings
  const videoMappings = videoUrls
    .map((url, i) => `  video${i + 1}: "${assetBaseUrl}${url}",`)
    .join("\n");
  const imageMappings = imageUrls
    .map((url, i) => `  image${i + 1}: "${assetBaseUrl}${url}",`)
    .join("\n");

  return `
import React from "react";
import { registerRoot, Composition, Sequence, useCurrentFrame, useVideoConfig } from "remotion";
import { interpolate } from "remotion";
import { AbsoluteFill } from "remotion";

// Asset URLs (served by local HTTP server)
export const ASSETS = {
${videoMappings}
${imageMappings}
};

// User-provided composition code
${userCode}

// Root component
const RemotionRoot: React.FC = () => {
  return (
    <>
      <Composition
        id="VideoComposerComp"
        component={VideoComposerMain}
        durationInFrames={${durationInFrames}}
        fps={${fps}}
        width={${width}}
        height={${height}}
      />
    </>
  );
};

registerRoot(RemotionRoot);
`;
}

export async function POST(request: NextRequest) {
  let tempDir: string | null = null;
  let bundleLocation: string | null = null;
  let assetServer: http.Server | null = null;

  try {
    const body: VideoComposerRequest = await request.json();
    const { code, videos, images, duration, aspectRatio, fps } = body;

    if (!code) {
      return NextResponse.json(
        { success: false, error: "Missing Remotion code" },
        { status: 400 }
      );
    }

    // Calculate dimensions based on aspect ratio
    let width: number, height: number;
    switch (aspectRatio) {
      case "16:9":
        width = 1920;
        height = 1080;
        break;
      case "1:1":
        width = 1080;
        height = 1080;
        break;
      case "9:16":
      default:
        width = 1080;
        height = 1920;
        break;
    }

    const durationInFrames = Math.round(duration * fps);

    console.log(`[VideoComposer] Starting render - Duration: ${duration}s, Size: ${width}x${height}, FPS: ${fps}`);
    console.log(`[VideoComposer] Videos: ${videos?.length || 0}, Images: ${images?.length || 0}`);

    // Create temp directory
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), "video-composer-"));
    const outputPath = path.join(tempDir, "output.mp4");
    const entryPath = path.join(tempDir, "index.tsx");

    // Save assets to temp directory
    const { videoUrls, imageUrls } = await saveAssets(
      tempDir,
      videos || [],
      images || []
    );

    // Start asset server
    const { server, baseUrl } = await createAssetServer(
      tempDir,
      videos || [],
      images || []
    );
    assetServer = server;
    console.log(`[VideoComposer] Asset server started at ${baseUrl}`);

    // Create the composition code
    const compositionCode = createCompositionCode(
      code,
      baseUrl,
      videoUrls,
      imageUrls,
      width,
      height,
      fps,
      durationInFrames
    );

    // Write the entry point
    await fs.writeFile(entryPath, compositionCode);
    console.log(`[VideoComposer] Composition code written to ${entryPath}`);

    // Bundle
    console.log(`[VideoComposer] Bundling...`);
    bundleLocation = await bundle({
      entryPoint: entryPath,
      webpackOverride: (config) => config,
    });
    console.log(`[VideoComposer] Bundle created at ${bundleLocation}`);

    // Select composition
    const composition = await selectComposition({
      serveUrl: bundleLocation,
      id: "VideoComposerComp",
    });

    console.log(`[VideoComposer] Rendering...`);

    // Render
    await renderMedia({
      composition,
      serveUrl: bundleLocation,
      codec: "h264",
      outputLocation: outputPath,
    });

    console.log(`[VideoComposer] Render complete`);

    // Read output
    const outputBuffer = await fs.readFile(outputPath);
    const outputBase64 = `data:video/mp4;base64,${outputBuffer.toString("base64")}`;

    const outputStats = await fs.stat(outputPath);
    console.log(`[VideoComposer] Output size: ${(outputStats.size / 1024 / 1024).toFixed(2)}MB`);

    return NextResponse.json({
      success: true,
      video: outputBase64,
      duration: duration,
    });

  } catch (error) {
    console.error("[VideoComposer] Render error:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Render failed",
        details: error instanceof Error ? error.stack : undefined,
      },
      { status: 500 }
    );
  } finally {
    // Close asset server
    if (assetServer) {
      assetServer.close();
    }
    // Cleanup temp directory
    if (tempDir) {
      try {
        await fs.rm(tempDir, { recursive: true, force: true });
      } catch {
        // Ignore cleanup errors
      }
    }
    // Cleanup bundle
    if (bundleLocation) {
      try {
        await fs.rm(bundleLocation, { recursive: true, force: true });
      } catch {
        // Ignore cleanup errors
      }
    }
  }
}
